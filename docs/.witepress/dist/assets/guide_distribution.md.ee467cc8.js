import{_ as e,c as t,o,a}from"./app.3b6acc86.js";const y=JSON.parse('{"title":"Distribution Output Target","description":"","frontmatter":{},"headers":[{"level":2,"title":"How is this different from \\"dist-custom-elements-bundle\\" output target?","slug":"how-is-this-different-from-dist-custom-elements-bundle-output-target"},{"level":2,"title":"Config","slug":"config"},{"level":3,"title":"dir","slug":"dir"},{"level":3,"title":"empty","slug":"empty"},{"level":3,"title":"collectionDir","slug":"collectiondir"},{"level":3,"title":"transformAliasedImportPathsInCollection","slug":"transformaliasedimportpathsincollection"},{"level":2,"title":"Publishing","slug":"publishing"},{"level":2,"title":"Distribution Options","slug":"distribution-options"},{"level":3,"title":"Script tag","slug":"script-tag"},{"level":3,"title":"Importing the dist library using a bundler","slug":"importing-the-dist-library-using-a-bundler"},{"level":3,"title":"Importing the dist library into another Rindo app","slug":"importing-the-dist-library-into-another-rindo-app"}],"relativePath":"guide/distribution.md"}'),i={name:"guide/distribution.md"},n=a(`<h1 id="distribution-output-target" tabindex="-1">Distribution Output Target <a class="header-anchor" href="#distribution-output-target" aria-hidden="true">#</a></h1><p>The <code>dist</code> type is to generate the component(s) as a reusable library that can be self-lazy loading, such as <a href="https://www.npmjs.com/package/@navify/core" target="_blank" rel="noopener noreferrer">Navify</a>. When creating a distribution, the project&#39;s <code>package.json</code> will also have to be updated. However, the generated bundle is treeshakable, ensuring that only imported components will end up in the build.</p><div class="language-tsx"><span class="copy"></span><pre><code><span class="line"><span style="color:#FFCB6B;">outputTargets</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">dist</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">]</span></span>
<span class="line"></span></code></pre></div><h2 id="how-is-this-different-from-dist-custom-elements-bundle-output-target" tabindex="-1">How is this different from &quot;dist-custom-elements-bundle&quot; output target? <a class="header-anchor" href="#how-is-this-different-from-dist-custom-elements-bundle-output-target" aria-hidden="true">#</a></h2><p>The <code>dist-custom-elements-bundle</code> output target has been deprecated in <a href="https://github.com/navify/rindo/releases/tag/v2.16.0" target="_blank" rel="noopener noreferrer">Rindo v2.16.0</a> in favor of the <a href="./custom-elements.html"><code>dist-custom-elements</code> output target</a>. The information below is for historical purposes only.</p><p>To start, Rindo was designed to lazy-load itself only when the component was actually used on a page. There are many benefits to this approach, such as simply adding a script tag to any page and the entire library is available for use, yet only the components actually used are downloaded. For example, <a href="https://www.npmjs.com/package/@navify/core" target="_blank" rel="noopener noreferrer"><code>@navify/core</code></a> comes with over 100 components, but a one webpage may only need <code>nav-toggle</code>. Instead of requesting the entire component library, or generating a custom bundle for just <code>nav-toggle</code>, the <code>dist</code> output target is able to generate a tiny entry build ready to load any of its components on-demand.</p><p>The <code>dist-custom-elements-bundle</code> on the other hand is a direct build of the custom element that extends <code>HTMLElement</code>, without any lazy-loading. The custom elements bundle does not apply polyfills, nor automatically define each custom elements. This may be preferred for projects that will handle bundling, lazy-loading and defining the custom elements themselves.</p><p>Luckily, both builds can be generated at the same time, and shipped in the same distribution. It would be up to the consumer of your component library to decide which build to use.</p><h2 id="config" tabindex="-1">Config <a class="header-anchor" href="#config" aria-hidden="true">#</a></h2><h3 id="dir" tabindex="-1">dir <a class="header-anchor" href="#dir" aria-hidden="true">#</a></h3><p>The <code>dir</code> config specifies the public distribution directory. This directory is commonly the <code>dist</code> directory found within <a href="https://docs.npmjs.com/getting-started/packages" target="_blank" rel="noopener noreferrer">npm packages</a>. This directory is built and rebuilt directly from the source files. Additionally, since this is a build target, all files will be deleted and rebuilt after each build, so it&#39;s best to always copy source files into this directory. It&#39;s recommended that this directory not be committed to a repository.</p><p>This option defaults to <code>dist</code> when omitted from a Rindo configuration file.</p><h3 id="empty" tabindex="-1">empty <a class="header-anchor" href="#empty" aria-hidden="true">#</a></h3><p>By default, before each build the <code>dir</code> directory will be emptied of all files. To prevent this directory from being emptied, change this value to <code>false</code>.</p><p>This flag defaults to <code>true</code> when omitted from a Rindo configuration file.</p><h3 id="collectiondir" tabindex="-1">collectionDir <a class="header-anchor" href="#collectiondir" aria-hidden="true">#</a></h3><p>The <code>collectionDir</code> config specifies the output directory within the <a href="#dir">distribution directory</a> where the transpiled output of Rindo components will be written.</p><p>This option defaults to <code>collection</code> when omitted from a Rindo configuration file.</p><h3 id="transformaliasedimportpathsincollection" tabindex="-1">transformAliasedImportPathsInCollection <a class="header-anchor" href="#transformaliasedimportpathsincollection" aria-hidden="true">#</a></h3><p>This option will allow <a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping" target="_blank" rel="noopener noreferrer">path aliases</a> defined in a project&#39;s <code>tsconfig.json</code> to be transformed into relative paths in the code output under the <a href="#collectiondir">collectionDir</a> subdirectory for this output target. This does not affect imports for external packages.</p><p>An example of path transformation could look something like:</p><div class="language-ts"><span class="copy"></span><pre><code><span class="line"><span style="color:#676E95;font-style:italic;">// Source code</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> utils </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@utils</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Output code</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> utils </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">../path/to/utils</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>This flag defaults to <code>false</code> when omitted from a Rindo configuration file.</p><blockquote><p>If using the <code>dist-collection</code> output target directly, the same result can be achieved using the <code>transformAliasedImportPaths</code> flag on the target&#39;s config.</p></blockquote><h2 id="publishing" tabindex="-1">Publishing <a class="header-anchor" href="#publishing" aria-hidden="true">#</a></h2><p>Next you can publish your library to <a href="https://www.npmjs.com/" target="_blank" rel="noopener noreferrer">Node Package Manager (NPM)</a>. For more information about setting up the <code>package.json</code> file, and publishing, see: <a href="./publishing.html">Publishing A Component Library</a>.</p><h2 id="distribution-options" tabindex="-1">Distribution Options <a class="header-anchor" href="#distribution-options" aria-hidden="true">#</a></h2><p>Each output target&#39;s form of bundling and distribution has its own pros and cons. Luckily you can just worry about writing good source code for your component. Rindo will handle generating the various bundles and consumers of your library can decide how to apply your components to their external projects. Below are a few of the options.</p><h3 id="script-tag" tabindex="-1">Script tag <a class="header-anchor" href="#script-tag" aria-hidden="true">#</a></h3><ul><li>Use a script tag linked to a CDN copy of your published NPM module, for example: <code>&lt;script type=&quot;module&quot; src=&#39;https://cdn.jsdelivr.net/npm/my-name@0.0.1/dist/myname.js&#39;&gt;&lt;/script&gt;</code>.</li><li>The initial script itself is extremely tiny and does not represent the entire library. It&#39;s only a small registry.</li><li>You can use any or all components within your library anywhere within that webpage.</li><li>It doesn&#39;t matter if the actual component was written within the HTML or created with vanilla JavaScript, jQuery, React, etc.</li><li>Only the components used on that page will be requested and lazy-loaded.</li></ul><h3 id="importing-the-dist-library-using-a-bundler" tabindex="-1">Importing the <code>dist</code> library using a bundler <a class="header-anchor" href="#importing-the-dist-library-using-a-bundler" aria-hidden="true">#</a></h3><ul><li>Run <code>npm install my-name --save</code></li><li>Add an <code>import</code> within the root component: <code>import my-component</code>;</li><li>Rindo will automatically setup the lazy-loading capabilities for the Rindo library.</li><li>Then you can use the element anywhere in your template, JSX, HTML etc.</li></ul><h3 id="importing-the-dist-library-into-another-rindo-app" tabindex="-1">Importing the <code>dist</code> library into another Rindo app <a class="header-anchor" href="#importing-the-dist-library-into-another-rindo-app" aria-hidden="true">#</a></h3><ul><li>Run <code>npm install my-name --save</code></li><li>Add an <code>import</code> within the root component: <code>import my-component</code>;</li><li>Rindo will automatically setup the lazy-loading capabilities for the Rindo library.</li><li>Then you can use the element anywhere in your template, JSX, HTML etc.</li></ul>`,34),s=[n];function l(r,d,c,p,h,u){return o(),t("div",null,s)}const f=e(i,[["render",l]]);export{y as __pageData,f as default};
