import{_ as e,c as o,o as n,a}from"./app.3b6acc86.js";const u=JSON.parse('{"title":"Component Lifecycle Methods","description":"","frontmatter":{},"headers":[{"level":2,"title":"connectedCallback()","slug":"connectedcallback"},{"level":2,"title":"disconnectedCallback()","slug":"disconnectedcallback"},{"level":2,"title":"componentWillLoad()","slug":"componentwillload"},{"level":2,"title":"componentDidLoad()","slug":"componentdidload"},{"level":2,"title":"componentShouldUpdate()","slug":"componentshouldupdate"},{"level":2,"title":"componentWillRender()","slug":"componentwillrender"},{"level":2,"title":"componentDidRender()","slug":"componentdidrender"},{"level":2,"title":"componentWillUpdate()","slug":"componentwillupdate"},{"level":2,"title":"componentDidUpdate()","slug":"componentdidupdate"},{"level":2,"title":"Rendering State","slug":"rendering-state"},{"level":2,"title":"Lifecycle Hierarchy","slug":"lifecycle-hierarchy"},{"level":2,"title":"Async Lifecycle Methods","slug":"async-lifecycle-methods"}],"relativePath":"guide/component-lifecycle.md"}'),s={name:"guide/component-lifecycle.md"},t=a(`<h1 id="component-lifecycle-methods" tabindex="-1">Component Lifecycle Methods <a class="header-anchor" href="#component-lifecycle-methods" aria-hidden="true">#</a></h1><p>Components have numerous lifecycle methods which can be used to know when the component &quot;will&quot; and &quot;did&quot; load, update, and render. These methods can be added to a component to hook into operations at the right time.</p><p>Implement one of the following methods within a component class and Rindo will automatically call them in the right order:</p><h2 id="connectedcallback" tabindex="-1">connectedCallback() <a class="header-anchor" href="#connectedcallback" aria-hidden="true">#</a></h2><p>Called every time the component is connected to the DOM. When the component is first connected, this method is called before <code>componentWillLoad</code>.</p><p>It&#39;s important to note that this method can be called more than once, every time, the element is <strong>attached</strong> or <strong>moved</strong> in the DOM. For logic that needs to run every time the element is attached or moved in the DOM, it is considered a best practice to use this lifecycle method.</p><div class="language-tsx"><span class="copy"></span><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> el </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">my-cmp</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">body</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#A6ACCD;">(el)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// connectedCallback() called</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// componentWillLoad() called (first time)</span></span>
<span class="line"><span style="color:#A6ACCD;">el</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">remove</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// disconnectedCallback()</span></span>
<span class="line"><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">body</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#A6ACCD;">(el)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// connectedCallback() called again, but \`componentWillLoad()\` is not.</span></span>
<span class="line"></span></code></pre></div><p>This <code>lifecycle</code> hook follows the same semantics as the one described by the <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements" target="_blank" rel="noopener noreferrer">Custom Elements Spec</a></p><h2 id="disconnectedcallback" tabindex="-1">disconnectedCallback() <a class="header-anchor" href="#disconnectedcallback" aria-hidden="true">#</a></h2><p>Called every time the component is disconnected from the DOM, ie, it can be dispatched more than once, DO not confuse with a &quot;onDestroy&quot; kind of event.</p><p>This <code>lifecycle</code> hook follows the same semantics as the one described by the <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements" target="_blank" rel="noopener noreferrer">Custom Elements Spec</a>.</p><h2 id="componentwillload" tabindex="-1">componentWillLoad() <a class="header-anchor" href="#componentwillload" aria-hidden="true">#</a></h2><p>Called once just after the component is first connected to the DOM. Since this method is only called once, it&#39;s a good place to load data asynchronously and to setup the state without triggering extra re-renders.</p><p>A promise can be returned, that can be used to wait for the first <code>render()</code>.</p><h2 id="componentdidload" tabindex="-1">componentDidLoad() <a class="header-anchor" href="#componentdidload" aria-hidden="true">#</a></h2><p>Called once just after the component is fully loaded and the first <code>render()</code> occurs.</p><h2 id="componentshouldupdate" tabindex="-1">componentShouldUpdate() <a class="header-anchor" href="#componentshouldupdate" aria-hidden="true">#</a></h2><p>This hook is called when a component&#39;s <a href="./properties.html"><code>Prop</code></a> or <a href="./state.html"><code>State</code></a> property changes and a rerender is about to be requested. This hook receives three arguments: the new value, the old value and the name of the changed state. It should return a boolean to indicate if the component should rerender (<code>true</code>) or not (<code>false</code>).</p><p>A couple of things to notice is that this method will not be executed before the initial render, that is, when the component is first attached to the dom, nor when a rerender is already scheduled in the next frame.</p><p>Let\u2019s say the following two props of a component change synchronously:</p><div class="language-tsx"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">component</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">somePropA </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">42</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">component</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">somePropB </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">88</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>The <code>componentShouldUpdate</code> will be first called with arguments: <code>42</code>, <code>undefined</code> and <code>somePropA</code>. If it does return <code>true</code>, the hook will not be called again since the rerender is already scheduled to happen. Instead, if the first hook returned <code>false</code>, then <code>componentShouldUpdate</code> will be called again with <code>88</code>, <code>undefined</code> and <code>somePropB</code> as arguments, triggered by the <code>component.somePropB = 88</code> mutation.</p><p>Since the execution of this hook might be conditioned, it&#39;s not good to rely on it to watch for prop changes, instead use the <code>@Watch</code> decorator for that.</p><h2 id="componentwillrender" tabindex="-1">componentWillRender() <a class="header-anchor" href="#componentwillrender" aria-hidden="true">#</a></h2><p>Called before every <code>render()</code>.</p><p>A promise can be returned, that can be used to wait for the upcoming render.</p><h2 id="componentdidrender" tabindex="-1">componentDidRender() <a class="header-anchor" href="#componentdidrender" aria-hidden="true">#</a></h2><p>Called after every <code>render()</code>.</p><h2 id="componentwillupdate" tabindex="-1">componentWillUpdate() <a class="header-anchor" href="#componentwillupdate" aria-hidden="true">#</a></h2><p>Called when the component is about to be updated because some <code>Prop()</code> or <code>State()</code> changed. It&#39;s never called during the first <code>render()</code>.</p><p>A promise can be returned, that can be used to wait for the next render.</p><h2 id="componentdidupdate" tabindex="-1">componentDidUpdate() <a class="header-anchor" href="#componentdidupdate" aria-hidden="true">#</a></h2><p>Called just after the component updates. It&#39;s never called during the first <code>render()</code>.</p><h2 id="rendering-state" tabindex="-1">Rendering State <a class="header-anchor" href="#rendering-state" aria-hidden="true">#</a></h2><p>It&#39;s always recommended to make any rendered state updates within <code>componentWillRender()</code>, since this is the method which get called <em>before</em> the <code>render()</code> method. Alternatively, updating rendered state with the <code>componentDidLoad()</code>, <code>componentDidUpdate()</code> and <code>componentDidRender()</code> methods will cause another rerender, which isn&#39;t ideal for performance.</p><p>If state <em>must</em> be updated in <code>componentDidUpdate()</code> or <code>componentDidRender()</code>, it has the potential of getting components stuck in an infinite loop. If updating state within <code>componentDidUpdate()</code> is unavoidable, then the method should also come with a way to detect if the props or state is &quot;dirty&quot; or not (is the data actually different or is it the same as before). By doing a dirty check, <code>componentDidUpdate()</code> is able to avoid rendering the same data, and which in turn calls <code>componentDidUpdate()</code> again.</p><h2 id="lifecycle-hierarchy" tabindex="-1">Lifecycle Hierarchy <a class="header-anchor" href="#lifecycle-hierarchy" aria-hidden="true">#</a></h2><p>A useful feature of lifecycle methods is that they take their child component&#39;s lifecycle into consideration too. For example, if the parent component, <code>cmp-a</code>, has a child component, <code>cmp-b</code>, then <code>cmp-a</code> isn&#39;t considered &quot;loaded&quot; until <code>cmp-b</code> has finished loading. Another way to put it is that the deepest components finish loading first, then the <code>componentDidLoad()</code> calls bubble up.</p><p>In the example below we have a simple hierarchy of components. The numbered list shows the order of which the lifecycle methods will fire.</p><div class="language-html"><span class="copy"></span><pre><code><span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">cmp-a</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">cmp-b</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">cmp-c</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">cmp-c</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">cmp-b</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">cmp-a</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><ol><li><code>cmp-a</code> - <code>componentWillLoad()</code></li><li><code>cmp-b</code> - <code>componentWillLoad()</code></li><li><code>cmp-c</code> - <code>componentWillLoad()</code></li><li><code>cmp-c</code> - <code>componentDidLoad()</code></li><li><code>cmp-b</code> - <code>componentDidLoad()</code></li><li><code>cmp-a</code> - <code>componentDidLoad()</code></li></ol><p>Even if some components may or may not be already loaded, the entire component hierarchy waits on its child components to finish loading and rendering.</p><h2 id="async-lifecycle-methods" tabindex="-1">Async Lifecycle Methods <a class="header-anchor" href="#async-lifecycle-methods" aria-hidden="true">#</a></h2><p>Lifecycle methods can also return promises which allows the method to asynchronously retrieve data or perform any async tasks. A great example of this is fetching data to be rendered in a component. For example, this very site you&#39;re reading first fetches content data before rendering. But because <code>fetch()</code> is async, it&#39;s important that <code>componentWillLoad()</code> returns a <code>Promise</code> to ensure its parent component isn&#39;t considered &quot;loaded&quot; until all of its content has rendered.</p><p>Below is a quick example showing how <code>componentWillLoad()</code> is able to have its parent component wait on it to finish loading its data.</p><div class="language-tsx"><span class="copy"></span><pre><code><span class="line"><span style="color:#82AAFF;">componentWillLoad</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">fetch</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/some-data.json</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">response</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">response</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">json</span><span style="color:#F07178;">())</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">content</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">data</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div>`,46),l=[t];function c(p,d,r,i,h,m){return n(),o("div",null,l)}const D=e(s,[["render",c]]);export{u as __pageData,D as default};
